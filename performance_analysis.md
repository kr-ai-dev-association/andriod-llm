# 프롬프트 평가 성능 분석 보고서

## 현재 상황 요약

### 1. 시스템 설정
- **모델**: llama31-banyaa-q4_0.gguf
- **백엔드**: OpenCL (GPU 가속)
- **컨텍스트 크기 (n_ctx)**: 512
- **배치 크기 (n_batch)**: 32
- **마이크로 배치 크기 (n_ubatch)**: 4
- **GPU 레이어 수 (n_gpu_layers)**: 31
- **스레드 수 (n_threads)**: 8
- **KV 캐시 위치**: CPU (SET_ROWS 호환성을 위해 강제 할당)

### 2. 메모리 사용량
- **Native Heap**: 963 KB
- **Graphics (GPU 메모리)**: 4.3 GB
- **Total PSS**: 5.4 GB
- **Total RSS**: 5.5 GB

### 3. 성능 측정 결과

#### 프롬프트 평가 성능
- **총 토큰 수**: 368 토큰
- **총 소요 시간**: 60.464초 (약 1분)
- **평균 토큰당 시간**: **164.30 ms/token**
- **처리량**: 약 6.1 tokens/sec

**배치 처리 분석:**
- 프롬프트 평가는 64 토큰씩 청크로 나누어 처리됨
- 각 청크 처리 시간: 약 10초 (64 토큰)
- 배치 재사용 로직이 활성화되어 있음

#### 토큰 생성 성능
- **평균 토큰 생성 시간**: 약 **500 ms/token**
- **처리량**: 약 2 tokens/sec
- 각 토큰 생성마다 `llama_decode()` 호출 필요

### 4. 성능 병목 지점 분석

#### 주요 문제점

1. **KV 캐시가 CPU에 할당됨**
   - **영향**: GPU 연산 시 KV 캐시 데이터를 CPU ↔ GPU 간 전송해야 함
   - **결과**: 데이터 전송 오버헤드로 인한 성능 저하
   - **해결책**: OpenCL 백엔드의 SET_ROWS 지원 개선 또는 다른 최적화 방법 필요

2. **작은 배치 크기 (n_batch=32)**
   - **현재**: n_batch=32, n_ubatch=4
   - **영향**: GPU 활용률이 낮을 수 있음
   - **권장**: n_batch를 64 또는 128로 증가 고려

3. **프롬프트 평가 청크 크기**
   - **현재**: 64 토큰씩 처리
   - **영향**: 작은 청크로 인한 오버헤드
   - **권장**: n_batch와 일치시키거나 더 큰 청크 사용

4. **OpenCL 백엔드 동기화 오버헤드**
   - **의심**: Vulkan에서 OpenCL로 전환 후 동기화 오버헤드 가능
   - **확인 필요**: OpenCL 커맨드 큐 동기화 시간 측정

### 5. 성능 비교 기준

#### 일반적인 성능 목표 (참고)
- **프롬프트 평가**: 20-50 ms/token (목표)
- **토큰 생성**: 50-200 ms/token (목표)
- **현재 성능**: 목표 대비 **3-10배 느림**

#### 하드웨어 제약
- **디바이스**: Android 기기 (Adreno GPU 추정)
- **GPU**: OpenCL 지원 (Vulkan 대신 사용 중)
- **메모리**: 충분한 GPU 메모리 (4.3GB 사용 중)

### 6. 최적화 권장 사항

#### 즉시 적용 가능한 최적화

1. **배치 크기 증가**
   ```kotlin
   nBatch = 64  // 또는 128
   nUbatch = 8  // n_batch의 1/8 정도
   ```

2. **프롬프트 평가 청크 크기 조정**
   - n_batch와 일치시키거나 더 큰 값 사용
   - 현재: 64 → 권장: 64-128

3. **GPU 레이어 수 조정**
   - 현재: 31 (거의 모든 레이어)
   - VRAM 여유가 있다면 유지, 부족하면 감소

#### 중장기 최적화

1. **OpenCL SET_ROWS 지원 개선**
   - OpenCL 백엔드에 Q4_0 타입 SET_ROWS 구현
   - KV 캐시를 GPU에 할당하여 데이터 전송 오버헤드 제거

2. **동적 배치 크기 조정**
   - 프롬프트 길이에 따라 배치 크기 동적 조정
   - 짧은 프롬프트: 작은 배치, 긴 프롬프트: 큰 배치

3. **비동기 처리 최적화**
   - OpenCL 커맨드 큐 비동기 처리
   - CPU-GPU 동기화 최소화

### 7. 현재 상태 요약

#### ✅ 해결된 문제
- **크래시 해결**: KV 캐시를 CPU에 할당하여 SET_ROWS 크래시 해결
- **안정성**: 앱이 정상적으로 실행되고 토큰 생성 가능
- **OpenCL 백엔드**: 정상 작동 중

#### ⚠️ 성능 이슈
- **프롬프트 평가**: 매우 느림 (164 ms/token)
- **토큰 생성**: 느림 (500 ms/token)
- **KV 캐시 위치**: CPU에 있어 GPU 연산 시 오버헤드 발생

#### 🔄 개선 필요 사항
- 배치 크기 최적화
- OpenCL 백엔드 성능 튜닝
- KV 캐시 GPU 할당 (SET_ROWS 지원 개선 후)

### 8. 다음 단계

1. **배치 크기 증가 테스트**
   - n_batch를 64, 128로 증가하여 성능 측정
   - 최적 배치 크기 찾기

2. **프롬프트 평가 청크 크기 조정**
   - n_batch와 일치시키거나 더 큰 값 사용

3. **OpenCL 백엔드 프로파일링**
   - 각 연산의 GPU 실행 시간 측정
   - 동기화 오버헤드 확인

4. **KV 캐시 GPU 할당 재검토**
   - OpenCL SET_ROWS 지원 개선 후 테스트
   - 또는 다른 해결책 모색

